# Ensure that these values are added to the GitHub Actions develop environment secrets: AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY
# Also add these develop environment variables: AWS_ACCOUNT_ID, AWS_REGION, ECR_REPOSITORY_URL, ECS_CLUSTER_NAME, ECS_SERVICE_NAME

name: Java CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

concurrency:
  group: ci-ecr-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read

jobs:
  build_test:
    name: Java Build & Test
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4

    - name: Set up Java
      uses: actions/setup-java@v4
      with:
        distribution: temurin
        java-version: "17"
        cache: maven

    - name: Build & test [Maven]
      shell: bash
      run: |
        set -euo pipefail
        if [[ -f ./mvnw ]]; then
          chmod +x ./mvnw
          ./mvnw -B -ntp test package
        else
          mvn -B -ntp test package
        fi

  push_ecr:
    name: Docker Build & Push
    needs: build_test
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    environment: develop
    outputs:
      image: ${{ steps.vars.outputs.image }}
      sha_tag: ${{ steps.vars.outputs.sha_tag }}
      latest_tag: ${{ steps.vars.outputs.latest_tag }}

    permissions:
      contents: read

    steps:
    - uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ vars.AWS_REGION }}

    - name: Login to Amazon ECR
      uses: aws-actions/amazon-ecr-login@v2

    - name: Set image vars
      id: vars
      shell: bash
      run: |
        set -euo pipefail
        IMAGE="${{ vars.ECR_REPOSITORY_URL }}"
        {
          echo "image=${IMAGE}"
          echo "sha_tag=${IMAGE}:${GITHUB_SHA}"
          echo "latest_tag=${IMAGE}:latest"
        } >> "$GITHUB_OUTPUT"



    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Build and push
      uses: docker/build-push-action@v6
      with:
        context: .
        file: docker/Dockerfile
        push: true
        tags: |
          ${{ steps.vars.outputs.sha_tag }}
          ${{ steps.vars.outputs.latest_tag }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: Notify failure
      if: failure()
      run: |
        echo "::error::ECR push failed. Check AWS credentials and ECR repository URL."
        echo "ECR push failed. Check AWS credentials and ECR repository URL." >> "$GITHUB_STEP_SUMMARY"

  deploy_dev:
    name: Deploy (develop)
    needs: push_ecr
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    environment: develop

    permissions:
      contents: read

    steps:
    - uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ vars.AWS_REGION }}

    - name: Validate required variables
      shell: bash
      run: |
        set -euo pipefail
        missing=0
        ECR_RAW="${{ vars.ECR_REPOSITORY_URL }}"
        ECR_RAW="${ECR_RAW#\"}"
        ECR_RAW="${ECR_RAW%\"}"
        if [[ -z "${{ vars.NEW_RELIC_APP_NAME }}" ]]; then
          echo "::error::Missing required variable NEW_RELIC_APP_NAME in the develop environment."
          missing=1
        fi
        if [[ -z "${{ secrets.NEW_RELIC_LICENSE_KEY }}" ]]; then
          echo "::error::Missing required secret NEW_RELIC_LICENSE_KEY in the develop environment."
          missing=1
        fi
        if [[ -z "${{ vars.ECS_CLUSTER_NAME }}" ]]; then
          echo "::error::Missing required variable ECS_CLUSTER_NAME in the develop environment."
          missing=1
        fi
        if [[ -z "${{ vars.ECS_SERVICE_NAME }}" ]]; then
          echo "::error::Missing required variable ECS_SERVICE_NAME in the develop environment."
          missing=1
        fi
        if [[ -z "$ECR_RAW" ]]; then
          echo "::error::Missing required variable ECR_REPOSITORY_URL in the develop environment."
          missing=1
        fi
        if [[ "$missing" -ne 0 ]]; then
          exit 1
        fi

    - name: Install jq
      run: |
        sudo apt-get update -y
        sudo apt-get install -y jq

    - name: Register new task definition
      id: taskdef
      shell: bash
      run: |
        set -euo pipefail
        CLUSTER="${{ vars.ECS_CLUSTER_NAME }}"
        SERVICE="${{ vars.ECS_SERVICE_NAME }}"
        IMAGE="${{ needs.push_ecr.outputs.sha_tag }}"
        CONTAINER="${{ vars.ECS_CONTAINER_NAME }}"
        NR_APP_NAME="${{ vars.NEW_RELIC_APP_NAME }}"
        NR_LICENSE_KEY="${{ secrets.NEW_RELIC_LICENSE_KEY }}"
        if [[ -z "$CONTAINER" ]]; then
          CONTAINER="app"
        fi

        TD_ARN=$(aws ecs describe-services \
          --cluster "$CLUSTER" \
          --services "$SERVICE" \
          --query "services[0].taskDefinition" \
          --output text)

        aws ecs describe-task-definition \
          --task-definition "$TD_ARN" \
          --query "taskDefinition" \
          > taskdef.json

        jq --arg IMAGE "$IMAGE" --arg CONTAINER "$CONTAINER" \
           --arg NR_APP_NAME "$NR_APP_NAME" --arg NR_LICENSE_KEY "$NR_LICENSE_KEY" '
          .containerDefinitions |= map(
            if .name == $CONTAINER then
              .image = $IMAGE
              | .environment = (
                  (.environment // [])
                  | map(select(.name != "NEW_RELIC_APP_NAME" and .name != "NEW_RELIC_LICENSE_KEY"))
                  + [
                      {"name":"NEW_RELIC_APP_NAME","value":$NR_APP_NAME},
                      {"name":"NEW_RELIC_LICENSE_KEY","value":$NR_LICENSE_KEY}
                    ]
                )
            else . end
          )
          | del(
              .taskDefinitionArn,
              .revision,
              .status,
              .requiresAttributes,
              .compatibilities,
              .registeredAt,
              .registeredBy
            )
        ' taskdef.json > taskdef.new.json

        NEW_TD_ARN=$(aws ecs register-task-definition \
          --cli-input-json file://taskdef.new.json \
          --query "taskDefinition.taskDefinitionArn" \
          --output text)

        echo "task_definition_arn=$NEW_TD_ARN" >> "$GITHUB_OUTPUT"

    - name: Update ECS service
      shell: bash
      run: |
        set -euo pipefail
        aws ecs update-service \
          --cluster "${{ vars.ECS_CLUSTER_NAME }}" \
          --service "${{ vars.ECS_SERVICE_NAME }}" \
          --task-definition "${{ steps.taskdef.outputs.task_definition_arn }}"

    - name: Wait for deployment to complete
      run: |
        aws ecs wait services-stable \
          --cluster "${{ vars.ECS_CLUSTER_NAME }}" \
          --services "${{ vars.ECS_SERVICE_NAME }}"

    - name: Verify deployment
      run: |
        aws ecs describe-services \
          --cluster "${{ vars.ECS_CLUSTER_NAME }}" \
          --services "${{ vars.ECS_SERVICE_NAME }}" \
          --query "services[0].deployments[0].rolloutState" \
          --output text

    - name: Notify failure
      if: failure()
      run: |
        echo "::error::Deployment failed. Check ECS service events."
        echo "Deployment failed. Check ECS service events." >> "$GITHUB_STEP_SUMMARY"

  deploy_prod:
    name: Deploy (production)
    needs: [push_ecr, deploy_dev]
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    environment: production

    permissions:
      contents: read

    steps:
    - uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ vars.AWS_REGION }}

    - name: Validate required variables
      shell: bash
      run: |
        set -euo pipefail
        missing=0
        ECR_RAW="${{ vars.ECR_REPOSITORY_URL }}"
        ECR_RAW="${ECR_RAW#\"}"
        ECR_RAW="${ECR_RAW%\"}"
        if [[ -z "${{ vars.NEW_RELIC_APP_NAME }}" ]]; then
          echo "::error::Missing required variable NEW_RELIC_APP_NAME in the production environment."
          missing=1
        fi
        if [[ -z "${{ secrets.NEW_RELIC_LICENSE_KEY }}" ]]; then
          echo "::error::Missing required secret NEW_RELIC_LICENSE_KEY in the production environment."
          missing=1
        fi
        if [[ -z "${{ vars.ECS_CLUSTER_NAME }}" ]]; then
          echo "::error::Missing required variable ECS_CLUSTER_NAME in the production environment."
          missing=1
        fi
        if [[ -z "${{ vars.ECS_SERVICE_NAME }}" ]]; then
          echo "::error::Missing required variable ECS_SERVICE_NAME in the production environment."
          missing=1
        fi
        if [[ -z "$ECR_RAW" ]]; then
          echo "::error::Missing required variable ECR_REPOSITORY_URL in the production environment."
          missing=1
        fi
        if [[ -z "${{ needs.push_ecr.outputs.sha_tag }}" ]]; then
          echo "::error::Missing image tag from push_ecr output. Check push_ecr job outputs."
          missing=1
        fi
        if [[ "$missing" -ne 0 ]]; then
          exit 1
        fi

    - name: Install jq
      run: |
        sudo apt-get update -y
        sudo apt-get install -y jq

    - name: Register new task definition
      id: taskdef
      shell: bash
      run: |
        set -euo pipefail
        CLUSTER="${{ vars.ECS_CLUSTER_NAME }}"
        SERVICE="${{ vars.ECS_SERVICE_NAME }}"
        IMAGE="${{ needs.push_ecr.outputs.sha_tag }}"
        CONTAINER="${{ vars.ECS_CONTAINER_NAME }}"
        NR_APP_NAME="${{ vars.NEW_RELIC_APP_NAME }}"
        NR_LICENSE_KEY="${{ secrets.NEW_RELIC_LICENSE_KEY }}"
        if [[ -z "$CONTAINER" ]]; then
          CONTAINER="app"
        fi

        TD_ARN=$(aws ecs describe-services \
          --cluster "$CLUSTER" \
          --services "$SERVICE" \
          --query "services[0].taskDefinition" \
          --output text)

        aws ecs describe-task-definition \
          --task-definition "$TD_ARN" \
          --query "taskDefinition" \
          > taskdef.json

        jq --arg IMAGE "$IMAGE" --arg CONTAINER "$CONTAINER" \
           --arg NR_APP_NAME "$NR_APP_NAME" --arg NR_LICENSE_KEY "$NR_LICENSE_KEY" '
          .containerDefinitions |= map(
            if .name == $CONTAINER then
              .image = $IMAGE
              | .environment = (
                  (.environment // [])
                  | map(select(.name != "NEW_RELIC_APP_NAME" and .name != "NEW_RELIC_LICENSE_KEY"))
                  + [
                      {"name":"NEW_RELIC_APP_NAME","value":$NR_APP_NAME},
                      {"name":"NEW_RELIC_LICENSE_KEY","value":$NR_LICENSE_KEY}
                    ]
                )
            else . end
          )
          | del(
              .taskDefinitionArn,
              .revision,
              .status,
              .requiresAttributes,
              .compatibilities,
              .registeredAt,
              .registeredBy
            )
        ' taskdef.json > taskdef.new.json

        NEW_TD_ARN=$(aws ecs register-task-definition \
          --cli-input-json file://taskdef.new.json \
          --query "taskDefinition.taskDefinitionArn" \
          --output text)

        echo "task_definition_arn=$NEW_TD_ARN" >> "$GITHUB_OUTPUT"

    - name: Update ECS service
      shell: bash
      run: |
        set -euo pipefail
        aws ecs update-service \
          --cluster "${{ vars.ECS_CLUSTER_NAME }}" \
          --service "${{ vars.ECS_SERVICE_NAME }}" \
          --task-definition "${{ steps.taskdef.outputs.task_definition_arn }}"

    - name: Wait for deployment to complete
      run: |
        aws ecs wait services-stable \
          --cluster "${{ vars.ECS_CLUSTER_NAME }}" \
          --services "${{ vars.ECS_SERVICE_NAME }}"

    - name: Verify deployment
      run: |
        aws ecs describe-services \
          --cluster "${{ vars.ECS_CLUSTER_NAME }}" \
          --services "${{ vars.ECS_SERVICE_NAME }}" \
          --query "services[0].deployments[0].rolloutState" \
          --output text

    - name: Notify failure
      if: failure()
      run: |
        echo "::error::Production deployment failed. Check ECS service events."
        echo "Production deployment failed. Check ECS service events." >> "$GITHUB_STEP_SUMMARY"
